package importing

import (
	"crypto/sha256"
	"fmt"
	"reflect"
	"strings"

	"github.com/mitchellh/copystructure"
	"github.com/mitchellh/hashstructure"
	"github.com/mitchellh/mapstructure"
	"go.aporeto.io/elemental"
)

// Hash computes the hash of the given identifiable in its current state.
func Hash(obj Importable, manager elemental.ModelManager) (string, error) {

	if obj == nil {
		return "", fmt.Errorf("obj must not be nil")
	}

	if manager == nil {
		return "", fmt.Errorf("manager must not be nil")
	}

	data, err := sanitize(obj, manager)
	if err != nil {
		return "", fmt.Errorf("unable to sanitize data from indentifiable: %w", err)
	}

	return hash(data)
}

func sanitize(obj elemental.AttributeSpecifiable, manager elemental.ModelManager) (map[string]any, error) {

	// First, we check that the given object is an identifiable.
	ident, ok := obj.(elemental.Identifiable)
	if !ok {
		return nil, fmt.Errorf("given object is not an identifiable")
	}
	identity := ident.Identity()

	// Make a copy as we need to strip attributes.
	ocopy, err := copystructure.Copy(obj)
	if err != nil {
		return nil, fmt.Errorf("unable to deepcopy identifiable: %w", err)
	}
	obj = ocopy.(elemental.AttributeSpecifiable)

	// We remove any existing importHash and importLabel.
	if imp, ok := obj.(Importable); ok {
		imp.SetImportHash("")
		imp.SetImportLabel("")
	}

	// We convert the given object to a map.
	data, err := toMap(obj)
	if err != nil {
		return nil, err
	}

	// Then we get a pristine object with the same identity.
	pobj := manager.Identifiable(identity).(elemental.AttributeSpecifiable)

	// And we also convert it to a map.
	pdata, err := toMap(pobj)
	if err != nil {
		return nil, err
	}

	// We remove all keys with a zero or default values.
	data = cleanIrrelevantValues(data, pdata)

	// Finally we make another pass to remove even more.
	for k, v := range data {

		// We remove the unexposed, readonly or autogenerated values.
		spec := pobj.SpecificationForAttribute(strings.ToLower(k))

		if !spec.Exposed || spec.ReadOnly || spec.Autogenerated {
			delete(data, k)
			continue
		}

		// If the type is a ref, we recursively sanitize the nested object.
		if spec.Type == "ref" {

			vv := manager.IdentifiableFromString(spec.SubType)
			if err := mapstructure.Decode(v, vv); err != nil {
				return nil, err
			}

			m, err := sanitize(vv.(elemental.AttributeSpecifiable), manager)
			if err != nil {
				return nil, err
			}

			// If in the end, the map is empty, we remove the key.
			if len(m) == 0 {
				delete(data, k)
				continue
			}

			// Or we replace the object by it's cleaned map version
			data[k] = m
		}
	}

	return data, nil
}

func cleanIrrelevantValues(data, template map[string]any) map[string]any {

	for k, v := range data {

		if elemental.IsZero(v) {
			delete(data, k)
			continue
		}

		tv, ok := template[k]
		if !ok {
			continue
		}

		var shouldDelete bool

		switch vv := v.(type) {

		case map[string]any:
			if reflect.ValueOf(vv).Type().Name() != reflect.ValueOf(tv).Type().Name() {
				continue
			}

			vv = cleanIrrelevantValues(vv, tv.(map[string]any))

			if len(vv) == 0 {
				shouldDelete = true
			}

		default:
			shouldDelete = reflect.DeepEqual(v, tv)
		}

		if shouldDelete {
			delete(data, k)
		}
	}

	return data
}

func toMap(obj any) (map[string]any, error) {
	m := map[string]any{}
	if err := mapstructure.Decode(obj, &m); err != nil {
		return nil, err
	}
	return m, nil
}

func hash(data map[string]any) (string, error) {

	h, err := hashstructure.Hash(data, nil)
	if err != nil {
		return "", fmt.Errorf("unable hash data: %w", err)
	}

	return fmt.Sprintf("%x", sha256.New().Sum([]byte(fmt.Sprintf("%d", h)))), nil
}
